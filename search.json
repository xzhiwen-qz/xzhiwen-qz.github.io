[{"title":"Steam检测交易报价","url":"/archives/d68a3803/","content":"要使用Steam API检测交易报价（Trade Offer）的状态和内容，需通过Steam提供的接口结合API Key实现。以下是核心方法和注意事项：\n\n🔍 一、API检测报价的基本原理\n报价查询接口\n\nSteam开放了/IEconService/GetTradeOffers/v1等接口，允许通过APIKey查询交易报价的详细信息，包括报价状态（待接受&#x2F;已取消&#x2F;已接受）、交易物品、参与者SteamID等。\n示例请求：GET https://api.steampowered.com/IEconService/GetTradeOffers/v1/?key=YOUR_API_KEY&amp;get_sent_offers=1&amp;get_received_offers=1\n\n\n单笔报价验证接口\n\n第三方平台（如C5GAME）提供专用接口验证报价是否归属该平台。例如：POST /merchant/offer/v1/exists参数：tradeofferid=报价ID&amp;app-key=平台密钥\n\n\n\n\n⚙️ 二、实现步骤\n获取Steam API Key\n\n在Steam开发者后台申请API Key，需绑定已验证域名的网站（如localhost可用于测试）。\n\n\n调用报价检测接口\n\n使用官方接口查询报价状态：// Node.js示例（使用axios）const axios = require(&#x27;axios&#x27;);const url = `https://api.steampowered.com/IEconService/GetTradeOffers/v1/?key=$&#123;API_KEY&#125;&amp;tradeofferid=$&#123;OFFER_ID&#125;`;axios.get(url).then(response =&gt; &#123;    console.log(response.data); // 包含报价详情和状态&#125;);\n\n\n处理报价状态\n\n关键字段解析：\ntrade_offer_state：\n2 &#x3D; 已接受\n3 &#x3D; 已取消\n6 &#x3D; 待确认（需手机令牌验证）\n\n\nitems_to_give：对方提供的物品\nitems_to_receive：你提供的物品\n\n\n\n\n\n\n⚠️ 三、安全与风险防控\nAPI劫持防护\n\n风险：若API Key泄露，攻击者可窃取交易信息或取消报价（如伪造交易方并替换为假报价）。\n措施：\n定期重置API Key（管理页面）。\n绝不登录可疑网站或授权未知第三方应用。\n\n\n\n\n绑定手机令牌\n\n未绑定令牌的账户发起的报价可能被暂挂15天，且API无法绕过确认流程。\n\n\n\n\n🔄 四、替代方案：第三方API服务若需批量检测报价或获取实时价格，可考虑：\n\nSteamApis&#x2F;Steamlytics：提供缓存的市场数据接口，避免频繁请求被Steam限流。\nCSGO Trader Prices：一次性获取所有CS:GO物品价格（每8小时更新），适合库存估值。\n\n\n💎 五、总结建议\n基础流程：申请API Key → 调用GetTradeOffers接口 → 解析trade_offer_state状态。\n安全必做：绑定手机令牌 + 定期重置API Key + 仅信任正规平台。\n高效方案：对大规模应用（如交易平台），优先使用第三方聚合API降低请求频率。\n\n","categories":["技术"],"tags":["Steam","API"]},{"title":"SSH协议克隆Github仓库","url":"/archives/ae6ca5eb/","content":"要通过 SSH 协议克隆 GitHub 仓库，你需要先设置好 SSH 密钥并添加到 GitHub 账户，以下是完整的操作步骤：\n\n\n1、生成新的 SSH 密钥ssh-keygen -t rsa -C &quot;你的邮箱&quot;\n\n回车三次后，生成 id_rsa（私钥） 和 id_rsa.pub（公钥） 两个文件。\n2、将 SSH 公钥添加到 GitHub\n登录 GitHub，进入 Settings → SSH and GPG keys\n点击 New SSH key，粘贴公钥内容，设置标题后保存。\n\n3、测试 SSH 链接ssh -T git@github.com\n\nYou’ve successfully authenticated, but GitHub does not provide shell access.\n","categories":["技术"],"tags":["Github","SSH"]},{"title":"Nginx自动更新证书","url":"/archives/dc9924d0/","content":"在 Ubuntu 上使用 Let’s Encrypt 配置 Nginx SSL证书 并自动更新\n\n\n1、安装 Certbotapt install certbot python3-certbot-nginx\n\n2、配置 Nginxserver &#123;    listen 端口号;    server_name 域名地址;&#125;\n\n3、获取 SSL 证书certbot --nginx -d 域名地址\n\n输入邮箱，然后一路回车，即可安装成功！\n4、配置自动续期crontab -e\n\n选择第一个nano编辑器，也就是输入1后回车。\n0 0 1 * * /usr/bin/certbot renew --quiet\n\n添加完上面内容，即可在每月第一天自动续期证书。\n","categories":["技术"],"tags":["Ubuntu","Nginx","Let's Encrypt"]},{"title":"获取抖音直播源","url":"/archives/c4193ecb/","content":"可以直接获取flv和m3u8的直播源链接需要输入直播链接或者直播房间号\n\n\nimport reimport sysimport requestsDEBUG = Falseheaders = &#123;    &#x27;authority&#x27;: &#x27;v.douyin.com&#x27;,    &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1&#x27;,&#125;url = input(&#x27;请输入抖音直播链接或19位room_id：&#x27;)if re.match(r&#x27;\\d&#123;19&#125;&#x27;, url):    room_id = urlelse:    try:        url = re.search(r&#x27;(https.*)&#x27;, url).group(1)        response = requests.head(url, headers=headers)        url = response.headers[&#x27;location&#x27;]        room_id = re.search(r&#x27;\\d&#123;19&#125;&#x27;, url).group(0)    except Exception as e:        if DEBUG:            print(e)        print(&#x27;获取room_id失败&#x27;)        sys.exit(1)print(&#x27;room_id&#x27;, room_id)try:    headers.update(&#123;        &#x27;authority&#x27;: &#x27;webcast.amemv.com&#x27;,        &#x27;cookie&#x27;: &#x27;_tea_utm_cache_1128=&#123;%22utm_source%22:%22copy%22%2C%22utm_medium%22:%22android%22%2C%22utm_campaign%22:%22client_share%22&#125;&#x27;,    &#125;)    response = requests.get(&#x27;https://webcast.amemv.com/webcast/room/reflow/info/?verifyFp=&amp;type_id=0&amp;live_id=1&amp;room_id=&#123;&#125;&amp;sec_user_id=&amp;app_id=1128&amp;msToken=&amp;X-Bogus=&#x27;.format(room_id), headers=headers,).json()    print(response)    rtmp_pull_url = response[&#x27;data&#x27;][&#x27;room&#x27;][&#x27;stream_url&#x27;][&#x27;rtmp_pull_url&#x27;]    hls_pull_url = response[&#x27;data&#x27;][&#x27;room&#x27;][&#x27;stream_url&#x27;][&#x27;hls_pull_url&#x27;]    print(rtmp_pull_url)    print(hls_pull_url)except Exception as e:    if DEBUG:        print(e)    print(&#x27;获取real url失败&#x27;)\n","categories":["技术"],"tags":["TikTok","Python"]},{"title":"Steam令牌码生成","url":"/archives/63555b67/","content":"首先获取时间戳除以30取整，得到8个数，再补成8字节长度。然后读取maFile文件中存储的shared_secret密钥，以该密钥为key，将上述处理后的8字节时间戳作为加密信息进行哈希运算，得到一串16进制的数。最后从这串16进制字符串中取最后一位去掉高四做为偏移，在这串数中取四个字节，除26取余数5次得到5个数。从字母表中找到对应的值合起来就是我们要的令牌验证码。\n\n\nimport hashlibimport hmacimport structfrom base64 import b64decodefrom time import timedef get_steam_auth_code(secret: str, t: int = None) -&gt; str:    if not t:        t = int(time() / 30)    msg = struct.pack(&quot;&gt;Q&quot;, t)    key = b64decode(secret)    mac = hmac.new(key, msg, hashlib.sha1).digest()    offset = mac[-1] &amp; 0x0f    binary = struct.unpack(&#x27;&gt;L&#x27;, mac[offset:offset + 4])[0] &amp; 0x7fffffff    codestr = list(&#x27;23456789BCDFGHJKMNPQRTVWXY&#x27;)    chars = []    for _ in range(5):        chars.append(codestr[binary % 26])        binary //= 26    code = &#x27;&#x27;.join(chars)    return codeprint(get_steam_auth_code(&#x27;你的密钥&#x27;, ))\n","categories":["技术"],"tags":["Steam","Python"]}]