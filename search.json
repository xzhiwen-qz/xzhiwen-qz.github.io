[{"title":"QGraphicsPixmapItem添加动画","url":"/archives/d9dcb4c2/","content":"添加图片贴片时，设置简单动画效果如果要实现贴片左右来回移动，可以参考如下实现\n\n\ndef reverse_animation(self):    start = self.animation.startValue()    end = self.animation.endValue()    self.animation.setStartValue(end)    self.animation.setEndValue(start)    self.animation.start()self.animation = QVariantAnimation()self.animation.setDuration(200)self.animation.setStartValue(QPointF(0, 0))self.animation.setEndValue(QPointF(100, 0))self.animation.setEasingCurve(QEasingCurve.Linear)self.animation.valueChanged.connect(item.setPos)self.animation.finished.connect(self.reverse_animation)\n\n因为这个是单程动画，如果要实现来回移动的话，需要监听动画结束事件，然后切换起点终点后再重新启动动画！\n","categories":["技术"],"tags":["Python","Pyside6","QGraphicsPixmapItem"]},{"title":"Nginx反向代理Github个人博客","url":"/archives/d487a6b8/","content":"在 Ubuntu 上使用 Nginx 反向代理个人博客地址使用自定义域名方便记忆，也可以加速访问\n\n\nlocation / &#123;    proxy_pass https://你的用户名.github.io;    proxy_set_header Host 你的用户名.github.io;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;&#125;\n","categories":["技术"],"tags":["Nginx","Github"]},{"title":"SSH协议克隆Github仓库","url":"/archives/ae6ca5eb/","content":"要通过 SSH 协议克隆 GitHub 仓库，你需要先设置好 SSH 密钥并添加到 GitHub 账户，以下是完整的操作步骤：\n\n\n1、生成新的 SSH 密钥ssh-keygen -t rsa -C &quot;你的邮箱&quot;\n\n回车三次后，生成 id_rsa（私钥） 和 id_rsa.pub（公钥） 两个文件。\n2、将 SSH 公钥添加到 GitHub\n登录 GitHub，进入 Settings → SSH and GPG keys\n点击 New SSH key，粘贴公钥内容，设置标题后保存。\n\n3、测试 SSH 链接ssh -T git@github.com\n\nYou’ve successfully authenticated, but GitHub does not provide shell access.\n","categories":["技术"],"tags":["Github","SSH"]},{"title":"Steam令牌码生成","url":"/archives/63555b67/","content":"首先获取时间戳除以30取整，得到8个数，再补成8字节长度。然后读取maFile文件中存储的shared_secret密钥，以该密钥为key，将上述处理后的8字节时间戳作为加密信息进行哈希运算，得到一串16进制的数。最后从这串16进制字符串中取最后一位去掉高四做为偏移，在这串数中取四个字节，除26取余数5次得到5个数。从字母表中找到对应的值合起来就是我们要的令牌验证码。\n\n\nimport hashlibimport hmacimport structfrom base64 import b64decodefrom time import timedef get_steam_auth_code(secret: str, t: int = None) -&gt; str:    if not t:        t = int(time() / 30)    msg = struct.pack(&quot;&gt;Q&quot;, t)    key = b64decode(secret)    mac = hmac.new(key, msg, hashlib.sha1).digest()    offset = mac[-1] &amp; 0x0f    binary = struct.unpack(&#x27;&gt;L&#x27;, mac[offset:offset + 4])[0] &amp; 0x7fffffff    codestr = list(&#x27;23456789BCDFGHJKMNPQRTVWXY&#x27;)    chars = []    for _ in range(5):        chars.append(codestr[binary % 26])        binary //= 26    code = &#x27;&#x27;.join(chars)    return codeprint(get_steam_auth_code(&#x27;你的密钥&#x27;, ))\n","categories":["技术"],"tags":["Python","Steam"]},{"title":"Nginx自动更新证书","url":"/archives/dc9924d0/","content":"在 Ubuntu 上使用 Let’s Encrypt 配置 Nginx SSL证书 并自动更新\n\n\n1、安装 Certbotapt install certbot python3-certbot-nginx\n\n2、配置 Nginxserver &#123;    listen 端口号;    server_name 域名地址;&#125;\n\n3、获取 SSL 证书certbot --nginx -d 域名地址\n\n输入邮箱，然后一路回车，即可安装成功！\n4、配置自动续期crontab -e\n\n选择第一个nano编辑器，也就是输入1后回车。\n0 0 1 * * /usr/bin/certbot renew --quiet\n\n添加完上面内容，即可在每月第一天自动续期证书。\n","categories":["技术"],"tags":["Nginx","Ubuntu","Let's Encrypt"]},{"title":"Steam检测交易报价","url":"/archives/d68a3803/","content":"要使用Steam API检测交易报价（Trade Offer）的状态和内容，需通过Steam提供的接口结合API Key实现。以下是核心方法和注意事项：\n\n\n\n🔍 一、API检测报价的基本原理\n报价查询接口\n\nSteam开放了/IEconService/GetTradeOffers/v1等接口，允许通过APIKey查询交易报价的详细信息，包括报价状态（待接受&#x2F;已取消&#x2F;已接受）、交易物品、参与者SteamID等。\n示例请求：GET https://api.steampowered.com/IEconService/GetTradeOffers/v1/?key=YOUR_API_KEY&amp;get_sent_offers=1&amp;get_received_offers=1\n\n\n单笔报价验证接口\n\n第三方平台（如C5GAME）提供专用接口验证报价是否归属该平台。例如：POST /merchant/offer/v1/exists参数：tradeofferid=报价ID&amp;app-key=平台密钥\n\n\n\n\n⚙️ 二、实现步骤\n获取Steam API Key\n\n在Steam开发者后台申请API Key，需绑定已验证域名的网站（如localhost可用于测试）。\n\n\n调用报价检测接口\n\n使用官方接口查询报价状态：// Node.js示例（使用axios）const axios = require(&#x27;axios&#x27;);const url = `https://api.steampowered.com/IEconService/GetTradeOffers/v1/?key=$&#123;API_KEY&#125;&amp;tradeofferid=$&#123;OFFER_ID&#125;`;axios.get(url).then(response =&gt; &#123;    console.log(response.data); // 包含报价详情和状态&#125;);\n\n\n处理报价状态\n\n关键字段解析：\ntrade_offer_state：\n2 &#x3D; 已接受\n3 &#x3D; 已取消\n6 &#x3D; 待确认（需手机令牌验证）\n\n\nitems_to_give：对方提供的物品\nitems_to_receive：你提供的物品\n\n\n\n\n\n\n⚠️ 三、安全与风险防控\nAPI劫持防护\n\n风险：若API Key泄露，攻击者可窃取交易信息或取消报价（如伪造交易方并替换为假报价）。\n措施：\n定期重置API Key（管理页面）。\n绝不登录可疑网站或授权未知第三方应用。\n\n\n\n\n绑定手机令牌\n\n未绑定令牌的账户发起的报价可能被暂挂15天，且API无法绕过确认流程。\n\n\n\n\n🔄 四、替代方案：第三方API服务若需批量检测报价或获取实时价格，可考虑：\n\nSteamApis&#x2F;Steamlytics：提供缓存的市场数据接口，避免频繁请求被Steam限流。\nCSGO Trader Prices：一次性获取所有CS:GO物品价格（每8小时更新），适合库存估值。\n\n\n💎 五、总结建议\n基础流程：申请API Key → 调用GetTradeOffers接口 → 解析trade_offer_state状态。\n安全必做：绑定手机令牌 + 定期重置API Key + 仅信任正规平台。\n高效方案：对大规模应用（如交易平台），优先使用第三方聚合API降低请求频率。\n\n","categories":["技术"],"tags":["Steam","API"]},{"title":"获取抖音直播源","url":"/archives/c4193ecb/","content":"可以直接获取flv和m3u8的直播源链接需要输入直播链接或者直播房间号\n\n\nimport reimport sysimport requestsDEBUG = Falseheaders = &#123;    &#x27;authority&#x27;: &#x27;v.douyin.com&#x27;,    &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1&#x27;,&#125;url = input(&#x27;请输入抖音直播链接或19位room_id：&#x27;)if re.match(r&#x27;\\d&#123;19&#125;&#x27;, url):    room_id = urlelse:    try:        url = re.search(r&#x27;(https.*)&#x27;, url).group(1)        response = requests.head(url, headers=headers)        url = response.headers[&#x27;location&#x27;]        room_id = re.search(r&#x27;\\d&#123;19&#125;&#x27;, url).group(0)    except Exception as e:        if DEBUG:            print(e)        print(&#x27;获取room_id失败&#x27;)        sys.exit(1)print(&#x27;room_id&#x27;, room_id)try:    headers.update(&#123;        &#x27;authority&#x27;: &#x27;webcast.amemv.com&#x27;,        &#x27;cookie&#x27;: &#x27;_tea_utm_cache_1128=&#123;%22utm_source%22:%22copy%22%2C%22utm_medium%22:%22android%22%2C%22utm_campaign%22:%22client_share%22&#125;&#x27;,    &#125;)    response = requests.get(&#x27;https://webcast.amemv.com/webcast/room/reflow/info/?verifyFp=&amp;type_id=0&amp;live_id=1&amp;room_id=&#123;&#125;&amp;sec_user_id=&amp;app_id=1128&amp;msToken=&amp;X-Bogus=&#x27;.format(room_id), headers=headers,).json()    print(response)    rtmp_pull_url = response[&#x27;data&#x27;][&#x27;room&#x27;][&#x27;stream_url&#x27;][&#x27;rtmp_pull_url&#x27;]    hls_pull_url = response[&#x27;data&#x27;][&#x27;room&#x27;][&#x27;stream_url&#x27;][&#x27;hls_pull_url&#x27;]    print(rtmp_pull_url)    print(hls_pull_url)except Exception as e:    if DEBUG:        print(e)    print(&#x27;获取real url失败&#x27;)\n","categories":["技术"],"tags":["Python","TikTok"]},{"title":"QGraphicsSimpleTextItem自定义文字特效","url":"/archives/760d6f8e/","content":"文字特效贴片，可以设置一些列常规样式支持多行文本，自动处理多行文字边距和排列布局\n\n\nfrom PySide6.QtCore import QPointFfrom PySide6.QtGui import Qt, QFont, QColor, QPainterPath, QPolygonF, QBrush, QPixmapfrom PySide6.QtWidgets import QGraphicsDropShadowEffect, QGraphicsPolygonItemfrom PySide6.QtWidgets import QGraphicsRectItem, QGraphicsSimpleTextItem, QGraphicsPixmapItemclass TextInfo:    def __init__(self, params):        self.content = params.get(&#x27;content&#x27;, &#x27;默认文字&#x27;)        self.size = params.get(&#x27;size&#x27;, 40)        self.gap = self.size // 10        self.ziti = params.get(&#x27;ziti&#x27;, &#x27;黑体&#x27;)        self.border = params.get(&#x27;border&#x27;, &#x27;圆角&#x27;)        self.align = params.get(&#x27;align&#x27;, &#x27;居中&#x27;)        self.bold = params.get(&#x27;bold&#x27;, True)        self.italic = params.get(&#x27;italic&#x27;, True)        self.triangle = params.get(&#x27;triangle&#x27;, False)        self.color = params.get(&#x27;color&#x27;, &#x27;#000000&#x27;)        self.shadow = params.get(&#x27;shadow&#x27;, &#x27;#ffffff&#x27;)        self.background = params.get(&#x27;background&#x27;, &#x27;#00000000&#x27;)        self.image = params.get(&#x27;image&#x27;, None)class TextRect(QGraphicsRectItem):    def __init__(self, text, text_info):        super().__init__()        self.setPen(Qt.NoPen)        self.text_item = QGraphicsSimpleTextItem(text)        self.text_item.setBrush(QColor(text_info.color))        shadow_effect = QGraphicsDropShadowEffect()        shadow_effect.setBlurRadius(8)        shadow_effect.setColor(QColor(text_info.shadow))        shadow_effect.setOffset(3, 3)        self.text_item.setGraphicsEffect(shadow_effect)        font = QFont(text_info.ziti, text_info.size)        font.setBold(text_info.bold)        font.setItalic(text_info.italic)        self.text_item.setFont(font)        self.text_item.setParentItem(self)    def offset(self, x, y):        self.text_item.setPos(x, y)    def width(self):        return self.text_item.boundingRect().width()    def height(self):        return self.text_item.boundingRect().height()class PatchText(QGraphicsRectItem):    def __init__(self, params):        super().__init__()        self.setPen(Qt.NoPen)        self.text_info = TextInfo(params)        self.setBrush(QColor(self.text_info.background))        self.text_line_list = []        w, h = 0, self.text_info.gap * 2        for line in self.text_info.content.split(&#x27;\\n&#x27;):            if not line:                line = &#x27; &#x27; * 4            text_line = TextRect(line, self.text_info)            w = max(w, text_line.width() + self.text_info.gap * 8)            h += text_line.height() + self.text_info.gap            self.text_line_list.append(text_line)            text_line.setParentItem(self)        x, y = self.text_info.gap * 4, self.text_info.gap * 2        for text_line in self.text_line_list:            if self.text_info.align == &#x27;居中&#x27;:                x = (w - text_line.width()) // 2            if self.text_info.align == &#x27;右对齐&#x27;:                x = w - text_line.width() - self.text_info.gap * 4            text_line.setRect(0, y, w, text_line.height())            text_line.offset(x, y)            y += text_line.height() + self.text_info.gap        h = h + self.text_info.gap * 2        self.setRect(0, 0, w, h)        # 画一个倒三角形模拟消息框        if self.text_info.triangle:            side = self.text_info.gap * 10            triangle = QGraphicsPolygonItem()            triangle.setPen(Qt.NoPen)            points = QPolygonF([                QPointF(w - side * 2, h),                QPointF(w - side, h),                QPointF(w - side * 1.5, h + side * 0.5)            ])            triangle.setPolygon(points)            triangle.setBrush(QBrush(QColor(self.text_info.background)))            triangle.setParentItem(self)        # 居中添加一个图片        if self.text_info.image:            pixmap = QGraphicsPixmapItem()            pixmap.setZValue(-1)            pixmap.setPixmap(QPixmap(self.text_info.image))            pixmap.setParentItem(self)            x, y = (w - pixmap.boundingRect().width()) // 2, (h - pixmap.boundingRect().height()) // 2            pixmap.setPos(x, y)            xx = x * -1 if x &lt; 0 else 0            yy = y * -1 if y &lt; 0 else 0            self.setRect(0, 0, w + xx * 2, h + yy * 2)            self.setPos(xx, yy)    def paint(self, painter, option, widget=None):        if self.text_info.border != &#x27;圆角&#x27;:            super().paint(painter, option, widget)            return        radius = self.text_info.gap * 4        painter.save()        path = QPainterPath()        path.addRoundedRect(self.rect(), radius, radius)        if self.brush().style() != Qt.NoBrush:            painter.fillPath(path, self.brush())        if self.pen().style() != Qt.NoPen:            painter.setPen(self.pen())            painter.drawPath(path)        painter.restore()\n","categories":["技术"],"tags":["Python","Pyside6","QGraphicsSimpleTextItem"]}]